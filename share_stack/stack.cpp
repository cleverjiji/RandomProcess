#include "stack.h"#include "codecache.h"#include <unistd.h>extern CodeCacheManagement *cc_management;map<ORIGIN_ADDR, STACK_TYPE> ShareStack::stack_map;void ShareStack::relocate_return_address(MapInst *map_inst){	ASSERT(cc_management);	struct ucontext *uc = (struct ucontext*)get_curr_addr((ORIGIN_ADDR)(info->origin_uc));	ORIGIN_ADDR pc = uc->uc_mcontext.gregs[REG_RIP];	INFO("pc=0x%lx\n", pc);	map<ORIGIN_ADDR, STACK_TYPE>::iterator ret = stack_map.find(pc);	ASSERT(ret!=stack_map.end());	STACK_TYPE type = ret->second;	ORIGIN_ADDR origin_rbp = uc->uc_mcontext.gregs[REG_RBP];	ORIGIN_ADDR origin_rsp = uc->uc_mcontext.gregs[REG_RSP];	//caculate current stack framelk	ADDR curr_rbp = get_curr_addr(origin_rbp);	ADDR curr_rsp = get_curr_addr(origin_rsp);	ORIGIN_ADDR return_address = 0;	ORIGIN_ADDR new_ret_addr = 0;		switch(type){		case S_RSP:{			return_address = *(ADDR*)(curr_rsp);			new_ret_addr = map_inst->get_new_addr_from_old(return_address, \				cc_management->is_in_cc(return_address));			*(ADDR*)curr_rsp = new_ret_addr;}			break;		case S_RSP_A_4:{			return_address = *((ADDR*)curr_rsp + 1);			new_ret_addr = map_inst->get_new_addr_from_old(return_address, \				cc_management->is_in_cc(return_address));			*((ADDR*)curr_rsp + 1) = new_ret_addr;}			break;		case S_RBP_A_4:{			return_address = *((ADDR*)curr_rbp + 1);			new_ret_addr = map_inst->get_new_addr_from_old(return_address, \				cc_management->is_in_cc(return_address));			*((ADDR*)curr_rbp + 1) = new_ret_addr;			origin_rbp = *(ADDR*)curr_rbp;}			break;		default: ASSERT(0);	}	ERR("old_return_address(0x%lx)--->new_return_address(0x%lx)\n", return_address, new_ret_addr);	//unwind other stack frame	while(origin_rbp!=0){		curr_rbp = get_curr_addr(origin_rbp);		//get return address		return_address = *((ADDR*)curr_rbp + 1);		//update return address		new_ret_addr = map_inst->get_new_addr_from_old(return_address, cc_management->is_in_cc(return_address));		*((ADDR*)curr_rbp + 1) = new_ret_addr;		INFO("old_return_address(0x%lx)--->new_return_address(0x%lx)\n", return_address, new_ret_addr);		//prev rbp		origin_rbp = *(ADDR *)curr_rbp;	}}
void ShareStack::relocate_current_pc(MapInst *map_inst){
	ASSERT(cc_management);	struct ucontext *uc = (struct ucontext*)get_curr_addr((ORIGIN_ADDR)(info->origin_uc));	ORIGIN_ADDR pc = uc->uc_mcontext.gregs[REG_RIP];	ORIGIN_ADDR new_pc = map_inst->get_new_addr_from_old(pc, cc_management->is_in_cc(pc));	//update old pc	uc->uc_mcontext.gregs[REG_RIP] = new_pc;	INFO("old_pc(0x%lx)--->new_pc(0x%lx)\n", pc, new_pc);}