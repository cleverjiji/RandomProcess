#include "stack.h"#include "codecache.h"#include <unistd.h>extern CodeCacheManagement *cc_management;map<ORIGIN_ADDR, STACK_TYPE> ShareStack::stack_map;BOOL ShareStack::check_relocate(MapInst *map_inst){	ASSERT(cc_management);	if(info->process_id==0)		return true;		struct ucontext *uc = (struct ucontext*)get_curr_addr((ORIGIN_ADDR)(info->origin_uc));	ORIGIN_ADDR pc = uc->uc_mcontext.gregs[REG_RIP];	ORIGIN_ADDR origin_addr = map_inst->get_old_origin_addr(pc, cc_management->is_in_cc(pc));	map<ORIGIN_ADDR, STACK_TYPE>::iterator ret = stack_map.find(origin_addr);	if(ret==stack_map.end())		return false;	else		return true;}void ShareStack::relocate_return_address(MapInst *map_inst){	ASSERT(cc_management);	if(info->process_id==0)		return ;		struct ucontext *uc = (struct ucontext*)get_curr_addr((ORIGIN_ADDR)(info->origin_uc));	ORIGIN_ADDR pc = uc->uc_mcontext.gregs[REG_RIP];	//PRINT(COLOR_RED"            [STACK MIGRATION]: "COLOR_END"pc=0x%lx\n", pc);	ORIGIN_ADDR origin_addr = map_inst->get_old_origin_addr(pc, cc_management->is_in_cc(pc));	map<ORIGIN_ADDR, STACK_TYPE>::iterator ret = stack_map.find(origin_addr);		STACK_TYPE type = ret->second;	ORIGIN_ADDR origin_rbp = uc->uc_mcontext.gregs[REG_RBP];	ORIGIN_ADDR origin_rsp = uc->uc_mcontext.gregs[REG_RSP];	//caculate current stack frame	ADDR curr_rbp = get_curr_addr(origin_rbp);	ADDR curr_rsp = get_curr_addr(origin_rsp);	ORIGIN_ADDR return_address = 0;	ORIGIN_ADDR new_ret_addr = 0;		switch(type){		case S_RSP:{			return_address = *(ADDR*)(curr_rsp);			new_ret_addr = map_inst->get_new_addr_from_old(return_address, \				cc_management->is_in_cc(return_address));			*(ADDR*)curr_rsp = new_ret_addr;}			break;		case S_RSP_A_4:{			return_address = *((ADDR*)curr_rsp + 1);			new_ret_addr = map_inst->get_new_addr_from_old(return_address, \				cc_management->is_in_cc(return_address));			*((ADDR*)curr_rsp + 1) = new_ret_addr;}			break;		case S_RBP_A_4:{			return_address = *((ADDR*)curr_rbp + 1);			new_ret_addr = map_inst->get_new_addr_from_old(return_address, \				cc_management->is_in_cc(return_address));			*((ADDR*)curr_rbp + 1) = new_ret_addr;			origin_rbp = *(ADDR*)curr_rbp;}			break;		default: ASSERT(0);	}	PRINT(COLOR_RED"            [%5d STACK MIGRATION]: "COLOR_END"old_return_address(0x%lx)--->new_return_address(0x%lx)\n", \		info->process_id, return_address, new_ret_addr);	//unwind other stack frame	while(origin_rbp!=0){		curr_rbp = get_curr_addr(origin_rbp);		//get return address		return_address = *((ADDR*)curr_rbp + 1);		//update return address		new_ret_addr = map_inst->get_new_addr_from_old(return_address, cc_management->is_in_cc(return_address));		*((ADDR*)curr_rbp + 1) = new_ret_addr;		PRINT(COLOR_RED"            [%5d STACK MIGRATION]: "COLOR_END"old_return_address(0x%lx)--->new_return_address(0x%lx)\n", \			info->process_id, return_address, new_ret_addr);		//prev rbp		origin_rbp = *(ADDR *)curr_rbp;	}	return ;}
void ShareStack::relocate_current_pc(MapInst *map_inst){
	ASSERT(cc_management);	if(info->process_id==0)		return ;	struct ucontext *uc = (struct ucontext*)get_curr_addr((ORIGIN_ADDR)(info->origin_uc));	ORIGIN_ADDR pc = uc->uc_mcontext.gregs[REG_RIP];	ORIGIN_ADDR new_pc = map_inst->get_new_addr_from_old(pc, cc_management->is_in_cc(pc));	//update old pc	uc->uc_mcontext.gregs[REG_RIP] = new_pc;	PRINT(COLOR_YELLOW"            [%5d   PC  MIGRATION]: "COLOR_END"old_pc(0x%lx)--->new_pc(0x%lx)\n",info->process_id, pc, new_pc);}